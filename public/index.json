[{"content":" Web kvant\nCrypto kvant\nPwn kvant\nMisc kvant\n","permalink":"grigolo.mt/writeups/","summary":"Web kvant\nCrypto kvant\nPwn kvant\nMisc kvant","title":"CTF Writeups"},{"content":"","permalink":"grigolo.mt/talks/shors-algorithm/","summary":"","title":"A t|ket\u003e Implementation of Shor's Algorithm"},{"content":" The above video is the product of months worth of thinking, and three full days of intensive work.\nAlexander Farrugia is a senior lecturer at the Junior College who took the time to read about combinatory logic in his free time. He also wrote a series of articles attempting to explain the basics of this subject on quora!\nAfter giving a talk at an event hosted by the Malta Mathematical Society, a couple of years back from the writing of this article, Alex managed to pique my interest on the topic. Fast forward to the date of writing of this article, Alex taught me the basics of combinatory logic and we produced an animation using Manim – an engine for precise programmatic animations, designed for creating explanatory math videos.\nIt is safe to say, that currently, on this island, only Alex and myself hold some degree of knowledge on combinatory logic. We aimed to change that by participating in the Summer of Math Exposition #2 so that we can expose the topic, to a wider range of people, using friendly and understandable (hopefully) animations.\n","permalink":"grigolo.mt/talks/combinatory-logic/","summary":"The above video is the product of months worth of thinking, and three full days of intensive work.\nAlexander Farrugia is a senior lecturer at the Junior College who took the time to read about combinatory logic in his free time. He also wrote a series of articles attempting to explain the basics of this subject on quora!\nAfter giving a talk at an event hosted by the Malta Mathematical Society, a couple of years back from the writing of this article, Alex managed to pique my interest on the topic.","title":"An Introduction to Combinatory Logic"},{"content":" Main Results: Definition: Let $\\mathcal{G_{\\tiny 3}}$ be the set of possible 3 by 3 rubik\u0026rsquo;s cube distinct states (i.e. no corner twists, no sticker swapping etc.) reachable by a move $M$.\nWe show that $\\mathcal{G_{\\tiny 3}}$ is a group under move concatenation which is defined as follows:\nIf $M_{\\tiny 1}$ and $M_{\\tiny 2}$ are moves (or thereby sequences of them) then $M_{\\tiny 1} * M_{\\tiny 2}$ is simply the execution of move $M_{\\tiny 1}$ followed by that of $M_{\\tiny 2}$. It is also worth nothing that performing a move from two different states, is identical in both cases, as we do not look for the final state, but the sequence of moves it took to get there.\nRemark: It is trivial, but not obvious, that there are so many ways we can scramble a rubik\u0026rsquo;s cube. To obtain the following result, we rather observe a subset of all the possible permutations and combinations of putting together a rubik\u0026rsquo;s cube. The group of interest, happens to be of this order.\n$$\\begin{aligned}o(\\mathcal{G_{\\tiny 3}}) \u0026amp;= \\frac{12! \\times 8! \\times 3^8 \\times 2^{12}}{2 \\times 3} \\\\\\\\ \u0026amp;= 43, 252, 003, 274,489,856,000 \\end{aligned}$$\nResources: Slides Exercise Sheet by Janet Chen Jaap\u0026rsquo;s Puzzle Page ","permalink":"grigolo.mt/talks/rubiks/","summary":"Main Results: Definition: Let $\\mathcal{G_{\\tiny 3}}$ be the set of possible 3 by 3 rubik\u0026rsquo;s cube distinct states (i.e. no corner twists, no sticker swapping etc.) reachable by a move $M$.\nWe show that $\\mathcal{G_{\\tiny 3}}$ is a group under move concatenation which is defined as follows:\nIf $M_{\\tiny 1}$ and $M_{\\tiny 2}$ are moves (or thereby sequences of them) then $M_{\\tiny 1} * M_{\\tiny 2}$ is simply the execution of move $M_{\\tiny 1}$ followed by that of $M_{\\tiny 2}$.","title":"Rubik's Cubes with a sprinkle of combinatorics and group theory."},{"content":"based\n","permalink":"grigolo.mt/info/","summary":"based","title":"About me"},{"content":" We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!\nkvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later.\nIn essence, it envolved the decryption of a 3-stage encryption algorithm, which operated on some state vectors generated by each step. The first stage was a simple NOT, the second stage was a controlled NOT, and the third stage was a controlled CNOT.\nThanks to the basics track of the Qalypso Summer School I was able to fully understand the challenge and solve it using the intended method.\nkvant.py The first function in kvant.py is basically the application of the ket notation on a binary number.\ndef get_state(x): l = [0] * 2**len(x) l[int(x, 2)] = 1 return l In computer science terms, it maps a binary number string $b$ of length $n$ (corresponding to a decimal number $x$) to an array of size $2^n$ whose entries are all $0$ except for the $x^ \\text{th}$ one, which is $1$. An example: $$\\verb|get_state(\u0026lsquo;01\u0026rsquo;)| = \\ket{01} = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\end{pmatrix} = \\verb|[0, 1, 0, 0]|$$\nThe next two functions should be self explanatory:\ndef str2bin(s): return \u0026#39;\u0026#39;.join(bin(ord(i))[2:].zfill(8) for i in s) def bin2str(a): return \u0026#39;\u0026#39;.join(chr(int(a[i:i+8], 2)) for i in range(0, len(a), 8)) Encoding functions encode_1() Now comes the interesting part. The following function expects an initial state vector and creates a single qubit quantum circuit. Thus the initial state must be an array of size $2^1$.\ndef encode_1(initial_state): qc = QuantumCircuit(1) qc.initialize(initial_state) qc.x(0) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) It is to be noted that the above circuit performs the Qiskit .x() gate ( NOT ) on the $0^\\text{th}$ qubit of the circuit, returning the resultant state vector. Given our definitions of $\\ket{0}$ and $\\ket{1}$, the possible results can be as follows:\n$$\\verb|NOT| \\ket{0} = \\verb|NOT| \\begin{pmatrix} 1\\\\0\\end{pmatrix} = \\begin{pmatrix} 0\\\\1\\end{pmatrix} = \\ket{1}$$\n$$\\verb|NOT| \\ket{1} = \\verb|NOT| \\begin{pmatrix} 0\\\\1\\end{pmatrix} = \\begin{pmatrix} 1\\\\0\\end{pmatrix} = \\ket{0}$$\nencode_2() The second encoding function happens to be a 2-qubit circuit, hence expecting a state vector of size $2^2$ as an input.\ndef encode_2(initial_state): qc = QuantumCircuit(2) qc.initialize(initial_state) qc.cx(0, 1) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) This time however, a .cx() gate ( CNOT ) is being applied to the 2 qubits – the $0^\\text{th}$ and $1^\\text{st}$ bit being the target and control bits respectively (damn qiskit for inverting their order). The CNOT gate simply flips the target bit, only if the control bit is set to 1 and does nothing otherwise. Fortunately, mathematics comes to the rescue with a handy matrix definition for the CNOT gate:\n$$\\verb|CNOT| := \\begin{pmatrix} 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\0\u0026amp;0\u0026amp;0\u0026amp;1\\\\0\u0026amp;0\u0026amp;1\u0026amp;0\\\\0\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\end{pmatrix}$$\nIts effect on a 2-qubit state vector $M$ is replicable by swapping the $1^\\text{st}$ and $3^\\text{rd}$ entries of $M$ (starting from 0), i.e.\n$$\\verb|CNOT| \\begin{pmatrix}a\\\\b\\\\c\\\\d\\end{pmatrix} = \\begin{pmatrix} 1\u0026amp;0\u0026amp;0\u0026amp;0\\\\0\u0026amp;0\u0026amp;0\u0026amp;1\\\\0\u0026amp;0\u0026amp;1\u0026amp;0\\\\0\u0026amp;1\u0026amp;0\u0026amp;0\\\\\\end{pmatrix} \\begin{pmatrix}a\\\\b\\\\c\\\\d\\end{pmatrix}= \\begin{pmatrix}a\\\\d\\\\c\\\\b\\end{pmatrix}$$\nAn example with a prepared state $\\ket{11}$:\n$$\\verb|CNOT| \\ket{11} = \\verb|CNOT| \\begin{pmatrix}0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\end{pmatrix} = \\verb|[0,1,0,0]|$$\nencode_3() The third encoding function is a 3-qubit circuit, hence expecting a state vector of size $2^3$ as an input.\ndef encode_3(initial_state): qc = QuantumCircuit(3) qc.initialize(initial_state) qc.ccx(0, 1, 2) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) The last encoding function is a .ccx() gate ( CCNOT ), also known as the Toffoli gate, which acts on 3 qubits. The CCNOT gate is a controlled version of the CNOT gate, i.e. it flips the target bit only if both control bits are set to 1 and does nothing otherwise. The CCNOT gate is defined as follows:\n$$\\verb|CCNOT| := \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\\\end{pmatrix}$$\nAgain, it can be seen as swapping the $6^\\text{th}$ and $7^{th}$ entries (starting from 0) of a 3-qubit state vector $M$ like so:\n$$\\verb|CCNOT| \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\g\\\\h\\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\\\end{pmatrix} \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\g\\\\h\\end{pmatrix}= \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\h\\\\g\\end{pmatrix}$$\nEncrypting functions encrypt_1/2/3() The encrypt_1/2/3() functions are the ones that actually perform the \u0026rsquo;encryption\u0026rsquo;. The first one iterates over every bit, applying the encode_1() to it and concatenating all the entries of the resulting state vectors. The second and third functions do the same, but with the encode_2() and encode_3() functions over every pairs and triples of bits respectively.\nNote: After every encrypting function, the length of the encrypted message doubles!\nDry run using 'a' Consider the encryption with the following string – 'a'\n\u0026#39;a\u0026#39; = 97 ↓ str2bin()\n01100001 ↓ encode_1()\nnot |0\u0026gt; not |1\u0026gt; not |1\u0026gt; not |0\u0026gt; not |0\u0026gt; not |0\u0026gt; not |0\u0026gt; not |1\u0026gt; ↓ computing!\n|1\u0026gt; |0\u0026gt; |0\u0026gt; |1\u0026gt; |1\u0026gt; |1\u0026gt; |1\u0026gt; |0\u0026gt; ↓ expanding the states!\n01 10 10 01 01 01 01 10 ↓ encode_2() remember, first bit is target and second bit is control\ncnot |01\u0026gt; cnot |10\u0026gt; cnot |10\u0026gt; ... ↓ computing!\n|11\u0026gt; |10\u0026gt; |10\u0026gt; ... ↓ expanding the states!\n0001 0010 0010 0001 0001 0001 0001 0010 ↓ group every 3 bits (last one is wrong due to the short length of the message — length of message should be a multiple of 3)\n000 100 100 010 000 100 010 001 000 100 10 ↓ encode_3()\nccnot |000\u0026gt; ccnot |100\u0026gt; ccnot |100\u0026gt; ... ↓ computing!\n|000\u0026gt; |100\u0026gt; |100\u0026gt; ... ↓ expanding the states!\n10000000 00001000 0000100 ... Now that we\u0026rsquo;ve understood how the encrpytion occurs, it\u0026rsquo;s just a matter of reversing each function, by doing the right swaps and collapsing the array to the previous, shorter, bit string.\nMy Solution Download solve_kvant.py\ndef str2bin(s): return \u0026#39;\u0026#39;.join(bin(ord(i))[2:].zfill(8) for i in s) def bin2str(a): return \u0026#39;\u0026#39;.join(chr(int(a[i:i+8], 2)) for i in range(0, len(a), 8)) def decrypt_1(enc_1): dec_bin = \u0026#39;\u0026#39; for i in range(0, len(enc_1), 2): state = [int(x) for x in enc_1[i:i+2]] dec_bin += str(bin(state.index(0))[2:]) # swap 0 and 1 return dec_bin def decrypt_2(enc_2): enc_1 = \u0026#39;\u0026#39; for i in range(0, len(enc_2), 4): state = [int(x) for x in enc_2[i:i+4]] state[1], state[3] = state[3], state[1] # CNOT swap enc_1 += str(bin(state.index(1))[2:].zfill(2)) return enc_1 def decrypt_3(enc_3): enc_2 = \u0026#39;\u0026#39; for i in range(0, len(enc_3), 8): state = [int(x) for x in enc_3[i:i+8]] state[3], state[7] = state[7], state[3] # CCNOT swap enc_2 += str(bin(state.index(1))[2:].zfill(3)) return enc_2 with open(\u0026#39;enc.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: enc = str2bin(f.read()) # read file and convert to binary flag = bin2str(decrypt_1(decrypt_2(decrypt_3(enc)))) # full decrypt and convert to string print(flag) Flag = CyberErudites{W3lc0m3_7o_th3_w0rld_0f_Qu4ntum_C0mput1ng!}\nAn uninteded solution The beasts at SekaiCTF (winners) bruteforced the decryption process. It turns out that the search space for the decryption is very small, and the decryption can be done on a classical computer in a matter of seconds using the following script:\nwith open(\u0026#34;enc.txt\u0026#34;,\u0026#34;r\u0026#34;) as f: enc_3 = str2bin(f.read()) enc_3_map = {} for w in [\u0026#34;000\u0026#34;, \u0026#34;001\u0026#34;, \u0026#34;010\u0026#34;,\u0026#34;011\u0026#34;, \u0026#34;100\u0026#34;, \u0026#34;101\u0026#34;, \u0026#34;110\u0026#34;, \u0026#34;111\u0026#34;]: enc_3_map[encrypt_3(w)] = w enc_2 = \u0026#34;\u0026#34; for _ in range(0,len(enc_3),8): enc_2 += enc_3_map[enc_3[_:_+8]] enc_2_map = {} for w in [\u0026#34;00\u0026#34;, \u0026#34;01\u0026#34;, \u0026#34;10\u0026#34;,\u0026#34;11\u0026#34;]: enc_2_map[encrypt_2(w)] = w enc_1 = \u0026#34;\u0026#34; for _ in range(0,len(enc_2),4): enc_1 += enc_2_map[enc_2[_:_+4]] enc_1_map = {} for w in [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;]: enc_1_map[encrypt_1(w)] = w flag = \u0026#34;\u0026#34; for _ in range(0,len(enc_1), 2): flag += enc_1_map[enc_1[_:_+2]] print(bin2str(flag)) Credits: sahuang#6271\n","permalink":"grigolo.mt/writeup/misc/kvant/","summary":"We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!\nkvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later.","title":"kvant"},{"content":"\nHere is my PGP public key. You can use it to verify any digitally signed files by me, or to communicate with me privately and securely.\nMy email address is giorgio (at) grigolo (dot) mt\nClick the text to copy it. -----BEGIN PGP PUBLIC KEY BLOCK----- How to send PGP encrypted emails Most decent email clients (mutt, Thunderbird, Evolution, etc.) support PGP keys out of the box, you\u0026rsquo;ll just need to add a key in your account settings. If you use a webmail client, like Gmail, you can use a browser extension like FlowCrypt.\nHow to verify PGP signed files There are many tools which allow you to verify a signature on a file, such as GPG on Linux, Kleopatra on Windows, and GPG Suite on Mac.\n","permalink":"grigolo.mt/pgp/","summary":"Here is my PGP public key. You can use it to verify any digitally signed files by me, or to communicate with me privately and securely.\nMy email address is giorgio (at) grigolo (dot) mt\nClick the text to copy it. -----BEGIN PGP PUBLIC KEY BLOCK----- How to send PGP encrypted emails Most decent email clients (mutt, Thunderbird, Evolution, etc.) support PGP keys out of the box, you\u0026rsquo;ll just need to add a key in your account settings.","title":"My PGP Key"},{"content":"Please refer to the below timetable if needed.\n","permalink":"grigolo.mt/schedule/","summary":"Please refer to the below timetable if needed.","title":"My schedule"}]