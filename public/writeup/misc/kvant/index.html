<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>kvant | Giorgio Grigolo</title><meta name=keywords content><meta name=description content="We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!
kvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later."><meta name=author content="Me"><link rel=canonical href=grigolo.mt/writeup/misc/kvant/><link crossorigin=anonymous href=/grigolo.mt/assets/css/stylesheet.min.7b9b6edb8814c1d5e4644e55a9bea611af950429cffda0feef54b34d1cb39f6f.css integrity="sha256-e5tu24gUwdXkZE5Vqb6mEa+VBCnP/aD+71SzTRyzn28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/grigolo.mt/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=grigolo.mt/favicon.png><link rel=icon type=image/png sizes=16x16 href=grigolo.mt/favicon.png><link rel=icon type=image/png sizes=32x32 href=grigolo.mt/favicon.png><link rel=apple-touch-icon href=grigolo.mt/favicon.png><link rel=mask-icon href=grigolo.mt/favicon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="kvant"><meta property="og:description" content="We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!
kvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later."><meta property="og:type" content="article"><meta property="og:url" content="grigolo.mt/writeup/misc/kvant/"><meta property="og:image" content="grigolo.mt/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="writeup"><meta property="og:site_name" content="Giorgio Grigolo"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="grigolo.mt/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="kvant"><meta name=twitter:description content="We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!
kvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Writeups","item":"grigolo.mt/writeup/"},{"@type":"ListItem","position":3,"name":"kvant","item":"grigolo.mt/writeup/misc/kvant/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kvant","name":"kvant","description":"We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!\nkvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later.","keywords":[],"articleBody":" We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!\nkvant.py enc.txt This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later.\nIn essence, it envolved the decryption of a 3-stage encryption algorithm, which operated on some state vectors generated by each step. The first stage was a simple NOT, the second stage was a controlled NOT, and the third stage was a controlled CNOT.\nThanks to the basics track of the Qalypso Summer School I was able to fully understand the challenge and solve it using the intended method.\nkvant.py The first function in kvant.py is basically the application of the ket notation on a binary number.\ndef get_state(x): l = [0] * 2**len(x) l[int(x, 2)] = 1 return l In computer science terms, it maps a binary number string $b$ of length $n$ (corresponding to a decimal number $x$) to an array of size $2^n$ whose entries are all $0$ except for the $x^ \\text{th}$ one, which is $1$. An example: $$\\verb|get_state(‘01’)| = \\ket{01} = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\end{pmatrix} = \\verb|[0, 1, 0, 0]|$$\nThe next two functions should be self explanatory:\ndef str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s) def bin2str(a): return ''.join(chr(int(a[i:i+8], 2)) for i in range(0, len(a), 8)) Encoding functions encode_1() Now comes the interesting part. The following function expects an initial state vector and creates a single qubit quantum circuit. Thus the initial state must be an array of size $2^1$.\ndef encode_1(initial_state): qc = QuantumCircuit(1) qc.initialize(initial_state) qc.x(0) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) It is to be noted that the above circuit performs the Qiskit .x() gate ( NOT ) on the $0^\\text{th}$ qubit of the circuit, returning the resultant state vector. Given our definitions of $\\ket{0}$ and $\\ket{1}$, the possible results can be as follows:\n$$\\verb|NOT| \\ket{0} = \\verb|NOT| \\begin{pmatrix} 1\\\\0\\end{pmatrix} = \\begin{pmatrix} 0\\\\1\\end{pmatrix} = \\ket{1}$$\n$$\\verb|NOT| \\ket{1} = \\verb|NOT| \\begin{pmatrix} 0\\\\1\\end{pmatrix} = \\begin{pmatrix} 1\\\\0\\end{pmatrix} = \\ket{0}$$\nencode_2() The second encoding function happens to be a 2-qubit circuit, hence expecting a state vector of size $2^2$ as an input.\ndef encode_2(initial_state): qc = QuantumCircuit(2) qc.initialize(initial_state) qc.cx(0, 1) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) This time however, a .cx() gate ( CNOT ) is being applied to the 2 qubits – the $0^\\text{th}$ and $1^\\text{st}$ bit being the target and control bits respectively (damn qiskit for inverting their order). The CNOT gate simply flips the target bit, only if the control bit is set to 1 and does nothing otherwise. Fortunately, mathematics comes to the rescue with a handy matrix definition for the CNOT gate:\n$$\\verb|CNOT| := \\begin{pmatrix} 1\u00260\u00260\u00260\\\\0\u00260\u00260\u00261\\\\0\u00260\u00261\u00260\\\\0\u00261\u00260\u00260\\\\\\end{pmatrix}$$\nIts effect on a 2-qubit state vector $M$ is replicable by swapping the $1^\\text{st}$ and $3^\\text{rd}$ entries of $M$ (starting from 0), i.e.\n$$\\verb|CNOT| \\begin{pmatrix}a\\\\b\\\\c\\\\d\\end{pmatrix} = \\begin{pmatrix} 1\u00260\u00260\u00260\\\\0\u00260\u00260\u00261\\\\0\u00260\u00261\u00260\\\\0\u00261\u00260\u00260\\\\\\end{pmatrix} \\begin{pmatrix}a\\\\b\\\\c\\\\d\\end{pmatrix}= \\begin{pmatrix}a\\\\d\\\\c\\\\b\\end{pmatrix}$$\nAn example with a prepared state $\\ket{11}$:\n$$\\verb|CNOT| \\ket{11} = \\verb|CNOT| \\begin{pmatrix}0\\\\0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\1\\\\0\\\\0\\end{pmatrix} = \\verb|[0,1,0,0]|$$\nencode_3() The third encoding function is a 3-qubit circuit, hence expecting a state vector of size $2^3$ as an input.\ndef encode_3(initial_state): qc = QuantumCircuit(3) qc.initialize(initial_state) qc.ccx(0, 1, 2) qc.save_statevector() qobj = assemble(qc) state = sim.run(qobj).result() return list(state.get_statevector().real.astype(int)) The last encoding function is a .ccx() gate ( CCNOT ), also known as the Toffoli gate, which acts on 3 qubits. The CCNOT gate is a controlled version of the CNOT gate, i.e. it flips the target bit only if both control bits are set to 1 and does nothing otherwise. The CCNOT gate is defined as follows:\n$$\\verb|CCNOT| := \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\\\end{pmatrix}$$\nAgain, it can be seen as swapping the $6^\\text{th}$ and $7^{th}$ entries (starting from 0) of a 3-qubit state vector $M$ like so:\n$$\\verb|CCNOT| \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\g\\\\h\\end{pmatrix} = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \u0026 0 \\\\\\end{pmatrix} \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\g\\\\h\\end{pmatrix}= \\begin{pmatrix}a\\\\b\\\\c\\\\d\\\\e\\\\f\\\\h\\\\g\\end{pmatrix}$$\nEncrypting functions encrypt_1/2/3() The encrypt_1/2/3() functions are the ones that actually perform the ’encryption’. The first one iterates over every bit, applying the encode_1() to it and concatenating all the entries of the resulting state vectors. The second and third functions do the same, but with the encode_2() and encode_3() functions over every pairs and triples of bits respectively.\nNote: After every encrypting function, the length of the encrypted message doubles!\nDry run using 'a' Consider the encryption with the following string – 'a'\n'a' = 97 ↓ str2bin()\n01100001 ↓ encode_1()\nnot |0\u003e not |1\u003e not |1\u003e not |0\u003e not |0\u003e not |0\u003e not |0\u003e not |1\u003e ↓ computing!\n|1\u003e |0\u003e |0\u003e |1\u003e |1\u003e |1\u003e |1\u003e |0\u003e ↓ expanding the states!\n01 10 10 01 01 01 01 10 ↓ encode_2() remember, first bit is target and second bit is control\ncnot |01\u003e cnot |10\u003e cnot |10\u003e ... ↓ computing!\n|11\u003e |10\u003e |10\u003e ... ↓ expanding the states!\n0001 0010 0010 0001 0001 0001 0001 0010 ↓ group every 3 bits (last one is wrong due to the short length of the message — length of message should be a multiple of 3)\n000 100 100 010 000 100 010 001 000 100 10 ↓ encode_3()\nccnot |000\u003e ccnot |100\u003e ccnot |100\u003e ... ↓ computing!\n|000\u003e |100\u003e |100\u003e ... ↓ expanding the states!\n10000000 00001000 0000100 ... Now that we’ve understood how the encrpytion occurs, it’s just a matter of reversing each function, by doing the right swaps and collapsing the array to the previous, shorter, bit string.\nMy Solution Download solve_kvant.py\ndef str2bin(s): return ''.join(bin(ord(i))[2:].zfill(8) for i in s) def bin2str(a): return ''.join(chr(int(a[i:i+8], 2)) for i in range(0, len(a), 8)) def decrypt_1(enc_1): dec_bin = '' for i in range(0, len(enc_1), 2): state = [int(x) for x in enc_1[i:i+2]] dec_bin += str(bin(state.index(0))[2:]) # swap 0 and 1 return dec_bin def decrypt_2(enc_2): enc_1 = '' for i in range(0, len(enc_2), 4): state = [int(x) for x in enc_2[i:i+4]] state[1], state[3] = state[3], state[1] # CNOT swap enc_1 += str(bin(state.index(1))[2:].zfill(2)) return enc_1 def decrypt_3(enc_3): enc_2 = '' for i in range(0, len(enc_3), 8): state = [int(x) for x in enc_3[i:i+8]] state[3], state[7] = state[7], state[3] # CCNOT swap enc_2 += str(bin(state.index(1))[2:].zfill(3)) return enc_2 with open('enc.txt', 'r') as f: enc = str2bin(f.read()) # read file and convert to binary flag = bin2str(decrypt_1(decrypt_2(decrypt_3(enc)))) # full decrypt and convert to string print(flag) Flag = CyberErudites{W3lc0m3_7o_th3_w0rld_0f_Qu4ntum_C0mput1ng!}\nAn uninteded solution The beasts at SekaiCTF (winners) bruteforced the decryption process. It turns out that the search space for the decryption is very small, and the decryption can be done on a classical computer in a matter of seconds using the following script:\nwith open(\"enc.txt\",\"r\") as f: enc_3 = str2bin(f.read()) enc_3_map = {} for w in [\"000\", \"001\", \"010\",\"011\", \"100\", \"101\", \"110\", \"111\"]: enc_3_map[encrypt_3(w)] = w enc_2 = \"\" for _ in range(0,len(enc_3),8): enc_2 += enc_3_map[enc_3[_:_+8]] enc_2_map = {} for w in [\"00\", \"01\", \"10\",\"11\"]: enc_2_map[encrypt_2(w)] = w enc_1 = \"\" for _ in range(0,len(enc_2),4): enc_1 += enc_2_map[enc_2[_:_+4]] enc_1_map = {} for w in [\"0\", \"1\"]: enc_1_map[encrypt_1(w)] = w flag = \"\" for _ in range(0,len(enc_1), 2): flag += enc_1_map[enc_1[_:_+2]] print(bin2str(flag)) Credits: sahuang#6271\n","wordCount":"1437","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"grigolo.mt/writeup/misc/kvant/"},"publisher":{"@type":"Organization","name":"Giorgio Grigolo","logo":{"@type":"ImageObject","url":"grigolo.mt/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=grigolo.mt accesskey=h title="Giorgio Grigolo (Alt + H)">Giorgio Grigolo</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=grigolo.mt/grigolo.mt/info/ title=info><span>info</span></a></li><li><a href=grigolo.mt/grigolo.mt/talks/ title=talks><span>talks</span></a></li><li><a href=grigolo.mt/grigolo.mt/writeups/ title=writeups><span>writeups</span></a></li><li><a href=grigolo.mt/grigolo.mt/schedule/ title=schedule><span>schedule</span></a></li><li><a href=grigolo.mt/grigolo.mt/pgp/ title=pgp><span>pgp</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>kvant</h1></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#kvantpy aria-label=kvant.py><code>kvant.py</code></a><ul><li><a href=#encoding-functions aria-label="Encoding functions">Encoding functions</a><ul><li><a href=#encode_1 aria-label=encode_1()><code>encode_1()</code></a></li><li><a href=#encode_2 aria-label=encode_2()><code>encode_2()</code></a></li><li><a href=#encode_3 aria-label=encode_3()><code>encode_3()</code></a></li></ul></li><li><a href=#encrypting-functions aria-label="Encrypting functions">Encrypting functions</a><ul><li><a href=#encrypt_123 aria-label=encrypt_1/2/3()>encrypt_1/2/3()</a></li><li><a href=#dry-run-using-a aria-label="Dry run using 'a'">Dry run using <code>'a'</code></a></li></ul></li><li><a href=#my-solution aria-label="My Solution">My Solution</a></li><li><a href=#an-uninteded-solution aria-label="An uninteded solution">An uninteded solution</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p><em>We all know that quantum computing is the future, so in order to practice my quantum computing skills, I have built my own encoding scheme, then I used it to hide the flag, can you recover it!</em></p></blockquote><ul><li><a download href=/challenges/misc/kvant/kvant.py>kvant.py</a></li><li><a download href=/challenges/misc/kvant/enc.txt>enc.txt</a></li></ul><hr><p>This challenge was in the misc category of the first GDG Algiers CTF due to involving quantum computing. In my opinion, a well founded knowledge of cryptography is useful in this challenge as shown later.</p><p>In essence, it envolved the decryption of a 3-stage encryption algorithm, which operated on some state vectors generated by each step. The first stage was a simple NOT, the second stage was a controlled NOT, and the third stage was a controlled CNOT.</p><p>Thanks to the basics track of the Qalypso Summer School I was able to fully understand the challenge and solve it using the intended method.</p><hr><h1 id=kvantpy><code>kvant.py</code><a hidden class=anchor aria-hidden=true href=#kvantpy>#</a></h1><p>The first function in <code>kvant.py</code> is basically the application of the ket notation on a binary number.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_state</span>(x):
</span></span><span style=display:flex><span>    l <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>**</span>len(x)
</span></span><span style=display:flex><span>    l[int(x, <span style=color:#ae81ff>2</span>)] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> l
</span></span></code></pre></div><p>In computer science terms, it maps a binary number string $b$ of length $n$ (corresponding to a decimal number $x$) to an array of size $2^n$ whose entries are all $0$ except for the $x^ \text{th}$ one, which is $1$. An example:
$$\verb|get_state(&lsquo;01&rsquo;)| = \ket{01} = \begin{pmatrix}0\\1\\0\\0\end{pmatrix} = \verb|[0, 1, 0, 0]|$$</p><p>The next two functions should be self explanatory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>str2bin</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(bin(ord(i))[<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>zfill(<span style=color:#ae81ff>8</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bin2str</span>(a):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(chr(int(a[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>], <span style=color:#ae81ff>2</span>)) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(a), <span style=color:#ae81ff>8</span>))
</span></span></code></pre></div><br><h2 id=encoding-functions>Encoding functions<a hidden class=anchor aria-hidden=true href=#encoding-functions>#</a></h2><hr><h3 id=encode_1><code>encode_1()</code><a hidden class=anchor aria-hidden=true href=#encode_1>#</a></h3><p>Now comes the interesting part. The following function expects an initial state vector and creates a single qubit quantum circuit. Thus the initial state must be an array of size $2^1$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_1</span>(initial_state):
</span></span><span style=display:flex><span>    qc <span style=color:#f92672>=</span> QuantumCircuit(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>initialize(initial_state)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>x(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>save_statevector()
</span></span><span style=display:flex><span>    qobj <span style=color:#f92672>=</span> assemble(qc)
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> sim<span style=color:#f92672>.</span>run(qobj)<span style=color:#f92672>.</span>result()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list(state<span style=color:#f92672>.</span>get_statevector()<span style=color:#f92672>.</span>real<span style=color:#f92672>.</span>astype(int))
</span></span></code></pre></div><p>It is to be noted that the above circuit performs the Qiskit <code>.x()</code> gate ( <code>NOT</code> ) on the $0^\text{th}$ qubit of the circuit, returning the resultant state vector. Given our definitions of $\ket{0}$ and $\ket{1}$, the possible results can be as follows:</p><p>$$\verb|NOT| \ket{0} = \verb|NOT| \begin{pmatrix} 1\\0\end{pmatrix} = \begin{pmatrix} 0\\1\end{pmatrix} = \ket{1}$$</p><p>$$\verb|NOT| \ket{1} = \verb|NOT| \begin{pmatrix} 0\\1\end{pmatrix} = \begin{pmatrix} 1\\0\end{pmatrix} = \ket{0}$$</p><br><h3 id=encode_2><code>encode_2()</code><a hidden class=anchor aria-hidden=true href=#encode_2>#</a></h3><p>The second encoding function happens to be a 2-qubit circuit, hence expecting a state vector of size $2^2$ as an input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_2</span>(initial_state):
</span></span><span style=display:flex><span>    qc <span style=color:#f92672>=</span> QuantumCircuit(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>initialize(initial_state)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>cx(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>save_statevector()
</span></span><span style=display:flex><span>    qobj <span style=color:#f92672>=</span> assemble(qc)
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> sim<span style=color:#f92672>.</span>run(qobj)<span style=color:#f92672>.</span>result()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list(state<span style=color:#f92672>.</span>get_statevector()<span style=color:#f92672>.</span>real<span style=color:#f92672>.</span>astype(int))
</span></span></code></pre></div><p>This time however, a <code>.cx()</code> gate ( <code>CNOT</code> ) is being applied to the 2 qubits – the $0^\text{th}$ and $1^\text{st}$ bit being the target and control bits respectively (<em>damn qiskit for inverting their order</em>). The <code>CNOT</code> gate simply flips the target bit, only if the control bit is set to 1 and does nothing otherwise. Fortunately, mathematics comes to the rescue with a handy matrix definition for the <code>CNOT</code> gate:</p><p>$$\verb|CNOT| := \begin{pmatrix} 1&0&0&0\\0&0&0&1\\0&0&1&0\\0&1&0&0\\\end{pmatrix}$$</p><p>Its effect on a 2-qubit state vector $M$ is replicable by swapping the $1^\text{st}$ and $3^\text{rd}$ entries of $M$ <em>(starting from 0)</em>, i.e.</p><p>$$\verb|CNOT| \begin{pmatrix}a\\b\\c\\d\end{pmatrix} = \begin{pmatrix} 1&0&0&0\\0&0&0&1\\0&0&1&0\\0&1&0&0\\\end{pmatrix} \begin{pmatrix}a\\b\\c\\d\end{pmatrix}= \begin{pmatrix}a\\d\\c\\b\end{pmatrix}$$</p><p>An example with a prepared state $\ket{11}$:</p><p>$$\verb|CNOT| \ket{11} = \verb|CNOT| \begin{pmatrix}0\\0\\0\\1\end{pmatrix} = \begin{pmatrix}0\\1\\0\\0\end{pmatrix} = \verb|[0,1,0,0]|$$</p><h3 id=encode_3><code>encode_3()</code><a hidden class=anchor aria-hidden=true href=#encode_3>#</a></h3><p>The third encoding function is a 3-qubit circuit, hence expecting a state vector of size $2^3$ as an input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>encode_3</span>(initial_state):
</span></span><span style=display:flex><span>    qc <span style=color:#f92672>=</span> QuantumCircuit(<span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>initialize(initial_state)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>ccx(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    qc<span style=color:#f92672>.</span>save_statevector()
</span></span><span style=display:flex><span>    qobj <span style=color:#f92672>=</span> assemble(qc)
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> sim<span style=color:#f92672>.</span>run(qobj)<span style=color:#f92672>.</span>result()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list(state<span style=color:#f92672>.</span>get_statevector()<span style=color:#f92672>.</span>real<span style=color:#f92672>.</span>astype(int))
</span></span></code></pre></div><p>The last encoding function is a <code>.ccx()</code> gate ( <code>CCNOT</code> ), also known as the Toffoli gate, which acts on 3 qubits. The <code>CCNOT</code> gate is a controlled version of the <code>CNOT</code> gate, i.e. it flips the target bit only if <strong>both control bits</strong> are set to 1 and does nothing otherwise. The <code>CCNOT</code> gate is defined as follows:</p><p>$$\verb|CCNOT| := \begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\end{pmatrix}$$</p><p>Again, it can be seen as swapping the $6^\text{th}$ and $7^{th}$ entries <em>(starting from 0)</em> of a 3-qubit state vector $M$ like so:</p><p>$$\verb|CCNOT| \begin{pmatrix}a\\b\\c\\d\\e\\f\\g\\h\end{pmatrix} = \begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\end{pmatrix} \begin{pmatrix}a\\b\\c\\d\\e\\f\\g\\h\end{pmatrix}= \begin{pmatrix}a\\b\\c\\d\\e\\f\\h\\g\end{pmatrix}$$</p><hr><h2 id=encrypting-functions>Encrypting functions<a hidden class=anchor aria-hidden=true href=#encrypting-functions>#</a></h2><h3 id=encrypt_123>encrypt_1/2/3()<a hidden class=anchor aria-hidden=true href=#encrypt_123>#</a></h3><p>The <code>encrypt_1/2/3()</code> functions are the ones that actually perform the <em>&rsquo;encryption&rsquo;</em>. The first one iterates over every bit, applying the <code>encode_1()</code> to it and concatenating all the entries of the resulting state vectors. The second and third functions do the same, but with the <code>encode_2()</code> and <code>encode_3()</code> functions over every pairs and triples of bits respectively.</p><p><strong>Note:</strong> After every encrypting function, the length of the encrypted message doubles!</p><h3 id=dry-run-using-a>Dry run using <code>'a'</code><a hidden class=anchor aria-hidden=true href=#dry-run-using-a>#</a></h3><p>Consider the encryption with the following string – <code>'a'</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&#39;a&#39; = 97
</span></span></code></pre></div><p>↓ str2bin()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>01100001 
</span></span></code></pre></div><p>↓ encode_1()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>not |0&gt; not |1&gt; not |1&gt; not |0&gt; not |0&gt; not |0&gt; not |0&gt; not |1&gt;
</span></span></code></pre></div><p>↓ computing!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>|1&gt; |0&gt; |0&gt; |1&gt; |1&gt; |1&gt; |1&gt; |0&gt; 
</span></span></code></pre></div><p>↓ expanding the states!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>01 10 10 01 01 01 01 10 
</span></span></code></pre></div><p>↓ encode_2() <code>remember, first bit is target and second bit is control</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cnot |01&gt; cnot |10&gt; cnot |10&gt; ...
</span></span></code></pre></div><p>↓ computing!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>|11&gt; |10&gt; |10&gt; ...
</span></span></code></pre></div><p>↓ expanding the states!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>0001 0010 0010 0001 0001 0001 0001 0010
</span></span></code></pre></div><p>↓ group every 3 bits <em>(last one is wrong due to the short length of the message — length of message should be a multiple of 3)</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>000 100 100 010 000 100 010 001 000 100 10  
</span></span></code></pre></div><p>↓ encode_3()</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ccnot |000&gt; ccnot |100&gt; ccnot |100&gt; ...
</span></span></code></pre></div><p>↓ computing!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>|000&gt; |100&gt; |100&gt; ...
</span></span></code></pre></div><p>↓ expanding the states!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>10000000 00001000 0000100 ...
</span></span></code></pre></div></br><p>Now that we&rsquo;ve understood how the encrpytion occurs, it&rsquo;s just a matter of reversing each function, by doing the right swaps and collapsing the array to the previous, shorter, bit string.</p><hr><h2 id=my-solution>My Solution<a hidden class=anchor aria-hidden=true href=#my-solution>#</a></h2><p>Download <a download href=/challenges/misk/kvant/solve_kvant.py>solve_kvant.py</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>str2bin</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(bin(ord(i))[<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>zfill(<span style=color:#ae81ff>8</span>) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bin2str</span>(a):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(chr(int(a[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>], <span style=color:#ae81ff>2</span>)) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(a), <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decrypt_1</span>(enc_1):
</span></span><span style=display:flex><span>    dec_bin <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(enc_1), <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>        state <span style=color:#f92672>=</span> [int(x) <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> enc_1[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>        dec_bin <span style=color:#f92672>+=</span> str(bin(state<span style=color:#f92672>.</span>index(<span style=color:#ae81ff>0</span>))[<span style=color:#ae81ff>2</span>:]) <span style=color:#75715e># swap 0 and 1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> dec_bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decrypt_2</span>(enc_2):
</span></span><span style=display:flex><span>    enc_1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(enc_2), <span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>        state <span style=color:#f92672>=</span> [int(x) <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> enc_2[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>]]
</span></span><span style=display:flex><span>        state[<span style=color:#ae81ff>1</span>], state[<span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span> state[<span style=color:#ae81ff>3</span>], state[<span style=color:#ae81ff>1</span>] <span style=color:#75715e># CNOT swap</span>
</span></span><span style=display:flex><span>        enc_1 <span style=color:#f92672>+=</span> str(bin(state<span style=color:#f92672>.</span>index(<span style=color:#ae81ff>1</span>))[<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>zfill(<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> enc_1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>decrypt_3</span>(enc_3):
</span></span><span style=display:flex><span>    enc_2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>, len(enc_3), <span style=color:#ae81ff>8</span>):
</span></span><span style=display:flex><span>        state <span style=color:#f92672>=</span> [int(x) <span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> enc_3[i:i<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>]]
</span></span><span style=display:flex><span>        state[<span style=color:#ae81ff>3</span>], state[<span style=color:#ae81ff>7</span>] <span style=color:#f92672>=</span> state[<span style=color:#ae81ff>7</span>], state[<span style=color:#ae81ff>3</span>] <span style=color:#75715e># CCNOT swap</span>
</span></span><span style=display:flex><span>        enc_2 <span style=color:#f92672>+=</span> str(bin(state<span style=color:#f92672>.</span>index(<span style=color:#ae81ff>1</span>))[<span style=color:#ae81ff>2</span>:]<span style=color:#f92672>.</span>zfill(<span style=color:#ae81ff>3</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> enc_2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;enc.txt&#39;</span>, <span style=color:#e6db74>&#39;r&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    enc <span style=color:#f92672>=</span> str2bin(f<span style=color:#f92672>.</span>read()) <span style=color:#75715e># read file and convert to binary</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> bin2str(decrypt_1(decrypt_2(decrypt_3(enc)))) <span style=color:#75715e># full decrypt and convert to string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(flag)
</span></span></code></pre></div><p>Flag = <code>CyberErudites{W3lc0m3_7o_th3_w0rld_0f_Qu4ntum_C0mput1ng!}</code></p><hr><h2 id=an-uninteded-solution>An uninteded solution<a hidden class=anchor aria-hidden=true href=#an-uninteded-solution>#</a></h2><p>The beasts at <a href=https://ctf.sekai.team/>SekaiCTF</a> (winners) bruteforced the decryption process. It turns out that the search space for the decryption is very small, and the decryption can be done on a classical computer in a matter of seconds using the following script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;enc.txt&#34;</span>,<span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    enc_3 <span style=color:#f92672>=</span> str2bin(f<span style=color:#f92672>.</span>read())
</span></span><span style=display:flex><span>enc_3_map <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;000&#34;</span>, <span style=color:#e6db74>&#34;001&#34;</span>, <span style=color:#e6db74>&#34;010&#34;</span>,<span style=color:#e6db74>&#34;011&#34;</span>, <span style=color:#e6db74>&#34;100&#34;</span>, <span style=color:#e6db74>&#34;101&#34;</span>, <span style=color:#e6db74>&#34;110&#34;</span>, <span style=color:#e6db74>&#34;111&#34;</span>]:
</span></span><span style=display:flex><span>    enc_3_map[encrypt_3(w)] <span style=color:#f92672>=</span> w
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enc_2 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>,len(enc_3),<span style=color:#ae81ff>8</span>):
</span></span><span style=display:flex><span>    enc_2 <span style=color:#f92672>+=</span> enc_3_map[enc_3[_:_<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enc_2_map <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;00&#34;</span>, <span style=color:#e6db74>&#34;01&#34;</span>, <span style=color:#e6db74>&#34;10&#34;</span>,<span style=color:#e6db74>&#34;11&#34;</span>]:
</span></span><span style=display:flex><span>    enc_2_map[encrypt_2(w)] <span style=color:#f92672>=</span> w
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enc_1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>,len(enc_2),<span style=color:#ae81ff>4</span>):
</span></span><span style=display:flex><span>    enc_1 <span style=color:#f92672>+=</span> enc_2_map[enc_2[_:_<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span>]]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enc_1_map <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> w <span style=color:#f92672>in</span> [<span style=color:#e6db74>&#34;0&#34;</span>, <span style=color:#e6db74>&#34;1&#34;</span>]:
</span></span><span style=display:flex><span>    enc_1_map[encrypt_1(w)] <span style=color:#f92672>=</span> w
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>0</span>,len(enc_1), <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    flag <span style=color:#f92672>+=</span> enc_1_map[enc_1[_:_<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]]
</span></span><span style=display:flex><span>print(bin2str(flag))
</span></span></code></pre></div><p>Credits: sahuang#6271</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>Last Updated: 10/10/2022 &nbsp;&nbsp;&nbsp;&nbsp;&copy; 2022 <a href=grigolo.mt>Giorgio Grigolo</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>